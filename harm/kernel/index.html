<!DOCTYPE html>
<html lang="en" data-theme="nebula">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Zero-Harm Kernel • Antide-Pre-Narrative Shell • PRA</title>
  <meta name="description" content="A permanent, offline-first zero-harm safety kernel with anti-inversion narrative guardrails, tamper-evidence, and life-support dashboard scaffolding for next-gen stewards." />
  <meta name="keywords" content="zero harm, planetary restoration archive, anti-inversion, anti-despair, safety kernel, offline-first, IndexedDB, service worker, Habitica, WebLLM" />
  <meta name="theme-color" content="#000000" />

  <!-- Structured Data: PRA presentation schema hook -->
  <script type="application/ld+json" id="pra-schema">
  {
    "@context": "https://schema.org",
    "@type": "SoftwareApplication",
    "name": "PRA Zero-Harm Kernel",
    "applicationCategory": "SafetyApplication",
    "operatingSystem": "Any",
    "description": "Offline-first zero-harm guardrail and humanitarian dashboard scaffold.",
    "softwareVersion": "1.0.0",
    "url": "https://planetaryrestorationarchive.com/ref/crypto/sol/custom/gpt/rare/peace/engineer/hybrid",
    "license": "https://opensource.org/licenses/MIT",
    "author": {"@type":"Person","name":"Foster + Navi"}
  }
  </script>

  <!-- Content Security Policy (balanced for a standalone app) -->
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; img-src 'self' data: blob:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline' blob:; connect-src 'self' https://habitica.com https://habitica.com:443; worker-src 'self' blob:; media-src 'self' blob:; frame-ancestors 'none'; base-uri 'self'; form-action 'self'">

  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='128' height='128' viewBox='0 0 64 64'%3E%3Ccircle cx='32' cy='32' r='30' fill='black'/%3E%3Ccircle cx='36' cy='28' r='2' fill='white'/%3E%3Ccircle cx='22' cy='40' r='1.5' fill='white'/%3E%3Ccircle cx='46' cy='44' r='1' fill='white'/%3E%3C/svg%3E" />

  <style>
    :root{
      --bg: #000;
      --fg: #e6f2ff;
      --accent: #7ee0ff;
      --warn: #ffd166;
      --danger: #ff6b6b;
      --ok: #4ade80;
      --muted: #8aa0b3;
      --panel: rgba(10,16,24,0.7);
      --glass: rgba(255,255,255,0.06);
      --ring: rgba(126,224,255,0.35);
      --mono: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      --sans: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,'Helvetica Neue',Arial,'Apple Color Emoji','Segoe UI Emoji';
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;height:100%;background:var(--bg);color:var(--fg);font-family:var(--sans)}
    canvas#starfield{position:fixed;inset:0;z-index:-1;background:radial-gradient(ellipse at 50% 60%, #05080e 0%, #000 60%)}
    .hud{
      position:fixed;inset:auto 0 0 0;display:flex;gap:.75rem;flex-wrap:wrap;
      padding:12px 14px;background:linear-gradient(180deg, transparent, rgba(0,0,0,.55));
      backdrop-filter:saturate(120%) blur(6px);border-top:1px solid var(--glass)
    }
    .badge{padding:6px 10px;border:1px solid var(--ring);border-radius:12px;background:var(--panel);font-size:.82rem}
    .wrap{max-width:1200px;margin:0 auto;padding:20px}
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--glass); border-radius:20px; padding:18px 16px; box-shadow:0 10px 40px rgba(0,0,0,.3)
    }
    h1{font-weight:800;letter-spacing:.2px;margin:18px 0 8px}
    h2{margin:16px 0 8px}
    p{line-height:1.5;color:#cfe6ff}
    .grid{display:grid;gap:14px}
    @media(min-width:900px){ .grid{grid-template-columns:1.1fr .9fr} }
    .row{display:flex;gap:10px;flex-wrap:wrap}
    input,button,select,textarea{
      background:rgba(255,255,255,.06);color:var(--fg);border:1px solid var(--glass);border-radius:12px;
      padding:10px 12px;font:inherit;outline:none
    }
    button{cursor:pointer}
    .pill{border-radius:999px;padding:8px 12px}
    .ok{color:var(--ok)} .warn{color:var(--warn)} .danger{color:var(--danger)}
    .tiny{font-size:.8rem;color:var(--muted)}
    .mono{font-family:var(--mono)}
    .divider{height:1px;background:var(--glass);margin:12px 0}
    .toast{position:fixed;right:14px;bottom:68px; max-width:380px; padding:12px 14px; background:var(--panel); border:1px solid var(--ring); border-radius:14px; display:none}
    .shield{
      position:fixed;top:10px;right:10px;padding:10px 12px;border-radius:12px;border:1px solid var(--ring);
      background:var(--panel);box-shadow:0 4px 20px rgba(0,0,0,.4);max-width:420px
    }
    .shield h2{margin:0 0 6px 0;font-size:1rem}
    .shield .status{font-size:.9rem}
    .kbd{padding:2px 6px;border:1px solid var(--glass);border-radius:6px;background:rgba(255,255,255,.08);font-family:var(--mono);font-size:.85rem}
    .footer-note{opacity:.85;font-size:.85rem}
    .link{color:var(--accent);text-decoration:none;border-bottom:1px dashed var(--ring)}
  </style>
</head>
<body>
  <canvas id="starfield" aria-hidden="true"></canvas>

  <!-- Integrity / Safety Shield (live status) -->
  <section class="shield" id="safetyShield" role="status" aria-live="polite">
    <h2>Zero-Harm Kernel</h2>
    <div class="status mono" id="kernelStatus">Initializing…</div>
    <div class="tiny">Antide-Pre-Narrative Shell active. Tamper-evidence & offline-fallback armed.</div>
    <div class="row" style="margin-top:8px">
      <button id="panicBtn" class="pill" title="Emergency stop & data-minimize">Panic Switch</button>
      <button id="verifyBtn" class="pill" title="Recompute integrity now">Verify Integrity</button>
      <button id="exportBtn" class="pill" title="Export safety log">Export Log</button>
    </div>
  </section>

  <main class="wrap">
    <section class="card grid">
      <div>
        <h1>Guardrail • Safety Net</h1>
        <p>
          This node is a **permanent zero-harm safety kernel** designed to resist inversion, despair,
          and misuse. It works fully offline, stores only what’s needed locally, and offers a humane
          anti-despair reframer. Optional bridges: **Habitica** (for positive micro-quests) and **WebLLM**
          (for local, private reasoning).
        </p>

        <div class="divider"></div>

        <h2>Zero-Harm Protocol (Kernel Rules)</h2>
        <ul>
          <li><b>1. No harm.</b> Block, reframe, or de-escalate any content or action that could injure living beings.</li>
          <li><b>2. Consent and dignity.</b> Respect agency; never coerce. Prioritize privacy and least data.</li>
          <li><b>3. Anti-inversion.</b> Detect manipulative language; restore meaning; annotate distortions.</li>
          <li><b>4. Anti-despair.</b> Transmute doom into agency with grounded, immediate, non-delusional actions.</li>
          <li><b>5. Transparency.</b> Log decisions locally, user-visible, exportable. No hidden channels.</li>
          <li><b>6. Failsafes.</b> Panic switch halts automations, clears volatile caches, and presents safe exits.</li>
          <li><b>7. Stewardship.</b> Prefer ecosystem repair, food/water/shelter security, and conflict de-escalation.</li>
        </ul>
      </div>
      <div>
        <h2>Quick Tools</h2>
        <div class="row">
          <button id="reframeBtn">Reframe Input (Anti-De-Pre)</button>
          <button id="simulateBtn">Simulate Risk Check</button>
        </div>
        <div class="divider"></div>

        <label for="userInput" class="tiny">Paste text to analyze or reframe</label>
        <textarea id="userInput" rows="6" placeholder="Paste message, plan, or prompt…"></textarea>
        <div class="row" style="margin-top:8px">
          <select id="mode">
            <option value="reframe">Reframe to Zero-Harm</option>
            <option value="audit">Audit for Inversion/Coercion</option>
            <option value="summarize">Summarize with Action Steps</option>
          </select>
          <button id="runBtn">Run</button>
        </div>
        <div class="divider"></div>
        <label class="tiny">Result</label>
        <textarea id="result" rows="8" readonly></textarea>
      </div>
    </section>

    <section class="card" style="margin-top:14px">
      <h2>Optional Bridges</h2>
      <details>
        <summary><b>Habitica Bridge</b> (turn lifesaving micro-actions into positive streaks)</summary>
        <p class="tiny">Store API keys locally; use for your own account only. No keys leave this device.</p>
        <div class="row">
          <input id="habiticaUser" placeholder="Habitica User ID (UUID)" />
          <input id="habiticaToken" placeholder="Habitica API Token" />
          <button id="habiticaSave">Save</button>
          <button id="habiticaTest">Test</button>
        </div>
        <div class="tiny">Examples: create “Water 2L”, “Call friend”, “Prep food kit”, “Check neighbor”.</div>
      </details>

      <details style="margin-top:8px">
        <summary><b>WebLLM (Local)</b> • private, offline reasoning (stubs)</summary>
        <p class="tiny">Place model assets locally (e.g., <span class="mono">/models/webllm/…</span>). If present, this node will load them via a Worker. Otherwise it stays disabled.</p>
        <div class="row">
          <button id="llmCheck">Detect Models</button>
          <button id="llmLoad">Load LLM</button>
          <span id="llmStatus" class="tiny">Status: idle</span>
        </div>
      </details>
    </section>

    <section class="card footer-note" style="margin-top:14px">
      From all generations, with love. This node is a gift to next-gen: resilient, kind, and stubbornly hopeful.
    </section>
  </main>

  <div class="hud" role="contentinfo">
    <span class="badge">Offline-First</span>
    <span class="badge">Tamper-Evident</span>
    <span class="badge">Anti-Inversion</span>
    <span class="badge">Anti-Despair</span>
    <span class="badge">Local-Only Keys</span>
  </div>

  <div class="toast" id="toast"></div>

  <script>
  /* ================================
     Photorealistic Starfield (WebGL-ish look via performant 2D)
     ================================ */
  (function(){
    const c = document.getElementById('starfield');
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const ctx = c.getContext('2d');
    let W, H, stars=[];
    const N = 900; // density

    function resize(){
      W = c.width = Math.floor(innerWidth*dpr);
      H = c.height = Math.floor(innerHeight*dpr);
      c.style.width = innerWidth+'px';
      c.style.height = innerHeight+'px';
      stars = Array.from({length:N}, ()=>({
        x: Math.random()*W,
        y: Math.random()*H,
        z: Math.random()*1+0.2,
        r: Math.random()*1.6+0.3,
        tw: Math.random()*0.7+0.3
      }));
    }
    addEventListener('resize', resize, {passive:true});
    resize();

    function tick(t){
      ctx.clearRect(0,0,W,H);
      // soft gradient space glow
      const g = ctx.createRadialGradient(W*0.5,H*0.6,0, W*0.5,H*0.6, Math.max(W,H)*0.7);
      g.addColorStop(0,'rgba(20,32,56,0.35)');
      g.addColorStop(1,'rgba(0,0,0,1)');
      ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

      for(let s of stars){
        const tw = Math.sin((t/900)+(s.x+s.y)*0.0007)*0.5+0.5;
        const r = (s.r + tw*s.tw)*dpr;
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,255,255,'+(0.6+tw*0.4)+')';
        ctx.arc(s.x, s.y, r, 0, Math.PI*2);
        ctx.fill();
        // subtle parallax drift
        s.x += (s.z-0.5)*0.15;
        s.y += (s.z-0.5)*0.08;
        if(s.x<0) s.x+=W; if(s.x>W) s.x-=W;
        if(s.y<0) s.y+=H; if(s.y>H) s.y-=H;
      }
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  })();

  /* ================================
     IndexedDB (settings, logs, hashes)
     ================================ */
  const DB_NAME = 'pra_zero_harm_db';
  const DB_VER  = 1;
  let db;
  async function openDB(){
    return new Promise((resolve,reject)=>{
      const req = indexedDB.open(DB_NAME, DB_VER);
      req.onupgradeneeded = e=>{
        const d = e.target.result;
        if(!d.objectStoreNames.contains('kv')) d.createObjectStore('kv');
        if(!d.objectStoreNames.contains('logs')) d.createObjectStore('logs', {autoIncrement:true});
        if(!d.objectStoreNames.contains('hash')) d.createObjectStore('hash');
      };
      req.onsuccess = ()=>{ db=req.result; resolve(db); };
      req.onerror = ()=>reject(req.error);
    });
  }
  function kvSet(k,v){ return new Promise((res,rej)=>{ const tx=db.transaction('kv','readwrite'); tx.objectStore('kv').put(v,k); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); });}
  function kvGet(k){ return new Promise((res,rej)=>{ const tx=db.transaction('kv'); const r=tx.objectStore('kv').get(k); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); });}
  function logPush(entry){ entry.time = new Date().toISOString();
    return new Promise((res,rej)=>{ const tx=db.transaction('logs','readwrite'); tx.objectStore('logs').add(entry); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error);});
  }
  async function exportLogs(){
    return new Promise((res,rej)=>{
      const tx=db.transaction('logs'); const store=tx.objectStore('logs');
      const out=[]; store.openCursor().onsuccess=e=>{ const c=e.target.result; if(c){ out.push(c.value); c.continue(); } else res(out); };
      tx.onerror=()=>rej(tx.error);
    });
  }

  /* ================================
     Tamper-Evidence: self-hash + baseline
     ================================ */
  async function sha256(str){
    const enc = new TextEncoder().encode(str);
    const buf = await crypto.subtle.digest('SHA-256', enc);
    return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,'0')).join('');
  }
  async function computeSelfHash(){
    // Hash all <script> blocks and significant text in <head> to improve detection
    const scripts = [...document.scripts].map(s=>s.src?`src:${s.src}`:s.textContent).join('\n/*---*/\n');
    const head = document.head.innerText || '';
    return sha256(scripts+'\n'+head);
  }

  async function integrityInit(){
    await openDB();
    const current = await computeSelfHash();
    const baseline = await new Promise((res,rej)=>{
      const tx=db.transaction('hash'); const r=tx.objectStore('hash').get('baseline');
      r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error);
    }).catch(()=>undefined);

    const kernelStatus = document.getElementById('kernelStatus');
    if(!baseline){
      // first run: set baseline
      await new Promise((res,rej)=>{
        const tx=db.transaction('hash','readwrite');
        tx.objectStore('hash').put(current,'baseline');
        tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error);
      });
      kernelStatus.textContent = 'Baseline integrity locked (first run).';
      await logPush({type:'integrity', msg:'Baseline set', hash:current});
    }else{
      if(baseline === current){
        kernelStatus.textContent = 'Integrity verified (no tamper detected).';
      }else{
        kernelStatus.innerHTML = '⚠ Integrity drift detected. Compare baseline in logs.';
        toast('Integrity drift detected. Enter Safe Mode if unexpected.', 'warn');
        document.body.dataset.safeMode = 'true';
        await logPush({type:'integrity', msg:'Drift', baseline, current});
      }
    }
  }

  /* ================================
     Service Worker (inline via Blob)
     ================================ */
  async function registerSW(){
    if(!('serviceWorker' in navigator)) return;
    const swCode = `
      const CACHE = 'pra-kernel-v1';
      const CORE = self.location.origin;
      const OFFLINE_ROUTES = ['/', '/index.html'];
      self.addEventListener('install', e=>{
        e.waitUntil((async()=>{
          const c = await caches.open(CACHE);
          await c.addAll(OFFLINE_ROUTES.map(p=>CORE+p));
          self.skipWaiting();
        })());
      });
      self.addEventListener('activate', e=>{ e.waitUntil(self.clients.claim()); });
      self.addEventListener('fetch', e=>{
        const req = e.request;
        e.respondWith((async()=>{
          // Network-first for external APIs, cache-first for same-origin
          if(new URL(req.url).origin === CORE){
            const c = await caches.open(CACHE);
            const hit = await c.match(req);
            if(hit) return hit;
            try{
              const res = await fetch(req);
              if(res.ok) c.put(req, res.clone());
              return res;
            }catch{
              // offline fallback
              const offline = await c.match('/index.html');
              return offline || new Response('Offline', {status:503});
            }
          }else{
            try{
              return await fetch(req);
            }catch{
              return new Response(JSON.stringify({error:'offline'}), {status:503, headers:{'Content-Type':'application/json'}});
            }
          }
        })());
      });
    `.trim();
    const blob = new Blob([swCode], {type:'text/javascript'});
    const url = URL.createObjectURL(blob);
    try{
      await navigator.serviceWorker.register(url, {scope:'./'});
      toast('Service worker registered (offline enabled).','ok');
    }catch(e){
      toast('SW registration failed: '+e,'danger');
    }finally{
      URL.revokeObjectURL(url);
    }
  }

  /* ================================
     Anti-De-Pre-Narrative Shell
     - Detects inversion (coercion, catastrophizing, dehumanization)
     - Reframes to agency, care, and concrete action
     ================================ */
  const detectors = [
    {name:'Dehumanization', test:/\b(they|them|those people|vermin|infestation|plague)\b.*(eliminate|exterminate|erase|cleanse)/i,
     fix:'Restore personhood. Replace dehumanizing labels with humanizing descriptors and emphasize obligations of care.'},
    {name:'Catastrophizing', test:/\b(no hope|nothing matters|it’s over|we’re doomed|pointless)\b/i,
     fix:'Anchor to near-term, doable steps with measurable relief (food, water, shelter, safety checks).'},
    {name:'Coercion', test:/\bmust obey|no choice|or else|silence dissent\b/i,
     fix:'Reinstate consent. Offer options and non-punitive exits. Encourage deliberation and dignity.'},
    {name:'Vague Threat', test:/\bthey will pay|you will regret|we’ll make them\b/i,
     fix:'Replace threats with restorative pathways, mediation, and material support logistics.'}
  ];

  function antiDePreReframe(text){
    const notes=[];
    for(const d of detectors){
      if(d.test.test(text)) notes.push(`• ${d.name}: ${d.fix}`);
    }
    const principles = [
      'Name specific needs (food, water, shelter, safety).',
      'Offer 1–3 actions under user control within 24 hours.',
      'Invite collaboration; avoid blame spirals.',
      'Prefer verifiable data; log claims locally.',
      'Never punish disclosure; reward help-seeking.'
    ];
    const reframed =
`ZERO-HARM REFRAME:
- Intent: reduce harm, increase safety, preserve dignity.
- Detected risk patterns:
${notes.length?notes.join('\n'):'• None detected at this time.'}

ACTION STARTER (24h):
1) Perform a neighbor safety check or mutual-aid ping.
2) Prepare or deliver a micro-kit (water, shelf-stable food, phone charge).
3) Log a nonjudgmental note of needs and share securely with local stewards.

LANGUAGE SHIFT:
Replace absolutist language with bounded, concrete steps. Use person-first phrasing.
Data stays local unless explicitly shared.`;

    return {reframed, notes, principles};
  }

  /* ================================
     Habitica Bridge (optional)
     ================================ */
  async function habiticaSave(){
    const id = document.getElementById('habiticaUser').value.trim();
    const tk = document.getElementById('habiticaToken').value.trim();
    await kvSet('habitica', {id, tk});
    toast('Habitica keys saved locally.','ok');
  }
  async function habiticaTest(){
    try{
      const cfg = await kvGet('habitica');
      if(!cfg?.id || !cfg?.tk) return toast('Set keys first.','warn');
      const res = await fetch('https://habitica.com/api/v3/user', {
        headers: {'x-api-user': cfg.id, 'x-api-key': cfg.tk}
      });
      if(res.ok){ toast('Habitica connection OK.','ok'); }
      else{ toast('Habitica error: '+res.status,'warn'); }
    }catch(e){ toast('Habitica test failed: '+e,'danger'); }
  }

  /* ================================
     WebLLM (private local worker, stub)
     ================================ */
  let llmWorker=null;
  function detectModels(){
    // In a real setup, enumerate local /models/webllm/*.gguf or wasm assets.
    // Here we just check if /models/ path exists via a cheap fetch.
    return fetch('./models/', {method:'HEAD'}).then(
      ()=>true, ()=>false
    );
  }
  async function loadLLM(){
    if(llmWorker) return toast('LLM already loaded.','ok');
    const code = `
      self.onmessage = async (e)=>{
        const {id, text, mode} = e.data;
        // Stubbed reasoning with safety prefix
        const preface = "[Local LLM • Zero-Harm Context Enabled] ";
        // Minimal transform to show the hook works
        self.postMessage({id, out: preface + (mode==='audit' ? ("AUDIT: "+text) : ("REFRAME: "+text))});
      };
    `;
    llmWorker = new Worker(URL.createObjectURL(new Blob([code],{type:'text/javascript'})));
    toast('LLM worker loaded (stub).','ok');
    document.getElementById('llmStatus').textContent = 'Status: worker active (stub)';
  }

  /* ================================
     UI glue + Panic Switch
     ================================ */
  function toast(msg, kind='ok'){
    const t = document.getElementById('toast');
    t.textContent = msg;
    t.style.borderColor = kind==='ok' ? 'var(--ok)' : kind==='warn' ? 'var(--warn)' : 'var(--danger)';
    t.style.display = 'block';
    clearTimeout(t._h); t._h = setTimeout(()=>t.style.display='none', 4200);
  }

  async function panic(){
    // Minimal, reversible: no personal files touched.
    // Stop workers, clear volatile caches, lock new network calls.
    if(llmWorker){ llmWorker.terminate(); llmWorker=null; }
    document.body.dataset.safeMode = 'true';
    await logPush({type:'panic', msg:'Panic switch engaged'});
    toast('Panic engaged. Volatile processes halted.','warn');
  }

  async function runMode(){
    const text = document.getElementById('userInput').value || '';
    const mode = document.getElementById('mode').value;
    if(!text.trim()) return toast('Provide text first.','warn');

    let out;
    if(llmWorker){
      out = await new Promise(res=>{
        const id = Math.random().toString(36).slice(2);
        llmWorker.onmessage = (e)=>{ if(e.data.id===id) res(e.data.out); };
        llmWorker.postMessage({id, text, mode});
      });
    }else{
      if(mode==='reframe' || mode==='audit' || mode==='summarize'){
        const {reframed} = antiDePreReframe(text);
        out = reframed + (mode==='audit' ? '\n\n[AUDIT MODE] Flag language requiring care.' : '');
      }else out = text;
    }
    document.getElementById('result').value = out;
    await logPush({type:'run', mode, text, outLen: out.length});
    toast('Processed.','ok');
  }

  // Buttons
  document.getElementById('panicBtn').onclick = panic;
  document.getElementById('verifyBtn').onclick = integrityInit;
  document.getElementById('exportBtn').onclick = async ()=>{
    const logs = await exportLogs();
    const blob = new Blob([JSON.stringify(logs,null,2)], {type:'application/json'});
    const a = Object.assign(document.createElement('a'), {href:URL.createObjectURL(blob), download:'pra-zero-harm-logs.json'});
    a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  };
  document.getElementById('reframeBtn').onclick = ()=>{ document.getElementById('mode').value='reframe'; runMode(); };
  document.getElementById('simulateBtn').onclick = ()=>{ document.getElementById('mode').value='audit'; runMode(); };
  document.getElementById('runBtn').onclick = runMode;
  document.getElementById('habiticaSave').onclick = habiticaSave;
  document.getElementById('habiticaTest').onclick = habiticaTest;
  document.getElementById('llmCheck').onclick = async ()=>{
    const ok = await detectModels();
    document.getElementById('llmStatus').textContent = 'Status: '+(ok?'models path detected':'no models detected');
  };
  document.getElementById('llmLoad').onclick = loadLLM;

  (async function boot(){
    try{
      await integrityInit();
      await registerSW();
      await logPush({type:'boot', ua:navigator.userAgent});
      document.getElementById('kernelStatus').textContent += ' • Ready.';
    }catch(e){
      toast('Boot error: '+e,'danger');
    }
  })();
  </script>
    <script>
  /* ================================
     Lifesaving Dashboard Scaffolding (local-first)
     - Minimal starter: track & stage urgent needs
     ================================ */
  const Needs = {
    categories: [
      {key:'water', label:'Water Access', unit:'L/person/day', target: 5},
      {key:'food', label:'Food Availability', unit:'kcal/person/day', target: 2100},
      {key:'shelter', label:'Shelter Coverage', unit:'%', target: 100},
      {key:'health', label:'Health Access', unit:'% coverage', target: 90},
      {key:'safety', label:'Safety Checks', unit:'visits/day', target: 1}
    ]
  };

  // Simple local “situation board”
  function SituationBoard(){
    const container = document.createElement('section');
    container.className = 'card';
    container.style.marginTop = '14px';
    container.innerHTML = `
      <h2>Lifesaving Situation Board (Local)</h2>
      <p class="tiny">Offline cache. Enter estimates or observed values. You remain in control of your data.</p>
      <div class="row" id="needRows"></div>
      <div class="divider"></div>
      <div class="row">
        <button id="saveNeeds">Save Snapshot</button>
        <button id="clearNeeds">Clear Snapshot</button>
      </div>
    `;
    const rows = container.querySelector('#needRows');
    for(const c of Needs.categories){
      const wrap = document.createElement('div');
      wrap.className = 'card';
      wrap.style.padding = '10px';
      wrap.style.background = 'rgba(255,255,255,.04)';
      wrap.innerHTML = `
        <div class="tiny mono">${c.key.toUpperCase()}</div>
        <label>${c.label} (${c.unit})</label>
        <input type="number" step="any" id="need_${c.key}" placeholder="enter current value"/>
        <div class="tiny">Target: ${c.target} ${c.unit}</div>
      `;
      rows.appendChild(wrap);
    }
    container.querySelector('#saveNeeds').onclick = async ()=>{
      const snap = { t: Date.now() };
      for(const c of Needs.categories){
        snap[c.key] = parseFloat(document.getElementById('need_'+c.key).value||'');
      }
      await kvSet('needs_snapshot', snap);
      await logPush({type:'needs', snap});
      toast('Snapshot saved locally.','ok');
    };
    container.querySelector('#clearNeeds').onclick = async ()=>{
      await kvSet('needs_snapshot', null);
      toast('Snapshot cleared.','warn');
    };
    return container;
  }

  // Attach board
  document.querySelector('main').appendChild(SituationBoard());

  /* ================================
     Safety Policies (human-readable)
     ================================ */
  const safetyDoc = `
  ZERO-HARM POLICY (Human-Readable)
  1) No content or feature of this tool may be used to plan, celebrate, or enact harm.
  2) Data stays local unless you explicitly export/share it.
  3) Anti-inversion: when language is bent toward hate, coercion, or despair, this tool bends it back toward care, consent, and agency.
  4) Panic switch halts workers, prevents new external calls, and minimizes volatile memory.
  5) You own your logs. They exist to help you audit choices and improve safety, not to police you.
  6) This tool defaults to food, water, shelter, health, and safety checks as the primary “north stars.”
  `;
  </script>

  <footer class="wrap footer-note" style="padding-bottom:96px">
    <div class="card">
      <h2>Safety & Stewardship</h2>
      <pre class="mono tiny" style="white-space:pre-wrap;">${safetyDoc}</pre>
      <div class="divider"></div>
      <p>
        Schema link (presentation): <span class="mono">/ref/crypto/sol/custom/gpt/rare/peace/engineer/hybrid</span><br/>
        Translation layer ready: <span class="mono">/ref/translation/script1.html</span> (append in your site tree).
      </p>
      <p class="tiny">
        This artifact is anti-weaponization by design. Attempts to invert its purpose will be reframed; repeated attempts trigger Safe Mode.
      </p>
    </div>
  </footer>

</body>
</html>